//task 1
/*Сравните области действия переменной и пусть ключевые слова
Если вы не знакомы с let, ознакомьтесь с этой задачей о разнице между letиvar .
Когда вы объявляете переменную с varключевым словом, она объявляется глобально или локально, если она объявлена ​​внутри функции.
Ключевое letслово ведет себя аналогично, но с некоторыми дополнительными функциями. Когда вы объявляете переменную с letключевым 
словом внутри блока, оператора или выражения, ее область действия ограничивается этим блоком, оператором или выражением.
Например:
var numArray = [];
for (var i = 0; i < 3; i++) {
  numArray.push(i);
}
console.log(numArray);
console.log(i);
Здесь консоль отобразит значения [0, 1, 2]и 3.
С varключевым словом iобъявляется глобально. Поэтому при i++выполнении он обновляет глобальную переменную. Этот код похож на 
следующий:
var numArray = [];
var i;
for (i = 0; i < 3; i++) {
  numArray.push(i);
}
console.log(numArray);
console.log(i);
Здесь консоль отобразит значения [0, 1, 2]и 3.
Такое поведение вызовет проблемы, если вы создадите функцию и сохраните ее для последующего использования внутри цикла for,
в котором используется iпеременная. Это связано с тем, что хранимая функция всегда будет ссылаться на значение обновленной
глобальной iпеременной.
var printNumTwo;
for (var i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo());
Здесь консоль отобразит значение 3.
Как вы можете видеть, printNumTwo()печатает 3, а не 2. Это связано с тем, что значение, назначенное для, iбыло обновлено, и 
printNumTwo()возвращает глобальное значение i, а не значение, iкоторое было при создании функции в цикле for. Ключевое 
letслово не следует этому поведению:
let printNumTwo;
for (let i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo());
console.log(i);
Здесь консоль отобразит значение 2и сообщение об ошибке i is not defined.
iне определен, потому что он не был объявлен в глобальной области. Он объявляется только в forоператоре цикла. printNumTwo()
вернул 
правильное значение, поскольку три разные iпеременные с уникальными значениями (0, 1 и 2) были созданы ключевым letсловом 
в операторе цикла.
Исправьте код так, чтобы iобъявленная в ifоператоре переменная была отдельной от iобъявленной в первой строке функции. 
Убедитесь, что varключевое 
слово нигде в вашем коде не используется.
Это упражнение предназначено для того, чтобы проиллюстрировать разницу между тем, как ключевые слова varи letназначают 
область действия объявленной переменной. 
При программировании функции, подобной той, что используется в этом упражнении, часто лучше использовать разные имена 
переменных, чтобы избежать путаницы.
*/
function checkScope() {
let i = 'function scope';
  if (true) {
    let i = 'block scope';
    console.log('Block scope i is: ', i);
  }
  console.log('Function scope i is: ', i);
  return i;
}
checkScope()
//task 2
/*Измените массив, объявленный с помощью const
Если вы не знакомы с const, проверьте этот вызов о constключевом слове .

Объявление constимеет множество вариантов использования в современном JavaScript.

Некоторые разработчики предпочитают присваивать всем своим переменным значение constпо умолчанию, если только они не знают, 
что им потребуется переназначить значение. Только в этом случае они используют let.

Однако важно понимать, что объекты (включая массивы и функции), назначенные переменной с помощью, constпо-прежнему могут
изменяться. Использование constобъявления только предотвращает переназначение идентификатора переменной.

const s = [5, 6, 7];
s = [1, 2, 3];
s[2] = 45;
console.log(s);
s = [1, 2, 3]приведет к ошибке. После комментирования этой строки console.logбудет отображаться значение [5, 6, 45].

Как видите, вы можете изменить [5, 6, 7]сам объект, и переменная sвсе равно будет указывать на измененный массив [5, 6, 45]. 
Как и все массивы, элементы массива sявляются изменяемыми, но поскольку constиспользуется, вы не можете использовать 
идентификатор переменной sдля указания на другой массив с помощью оператора присваивания.

Массив объявляется как const s = [5, 7, 2]. Измените массив на [2, 5, 7]использование различных назначений элементов.*/
const s = [5, 7, 2];
function editInPlace() {
  // Only change code below this line
s[0] = 2;
s[1] = 5;
s[2] = 7;
  // Using s = [2, 5, 7] would be invalid
  // Only change code above this line
}
editInPlace();

//task 3
/*Предотвратить мутацию объекта
Как видно из предыдущей задачи, constобъявление само по себе на самом деле не защищает ваши данные от изменений. 
Чтобы гарантировать, 
что ваши данные не изменятся, JavaScript предоставляет функцию Object.freezeпредотвращения изменения данных.

Любая попытка изменить объект будет отклонена с выдачей ошибки, если скрипт работает в строгом режиме.

let obj = {
  name:"FreeCodeCamp",
  review:"Awesome"
};
Object.freeze(obj);
obj.review = "bad";
obj.newProp = "Test";
console.log(obj); 
Присваивания obj.reviewи obj.newPropприведут к ошибкам, потому что наш редактор по умолчанию работает в строгом 
режиме, и в консоли будет отображаться значение { name: "FreeCodeCamp", review: "Awesome" }.

В этом задании вы будете использовать Object.freezeдля предотвращения изменения математических констант. 
Вам нужно заморозить MATH_CONSTANTSобъект, чтобы никто не мог изменить значение PI, добавить или удалить свойства.*/

function freezeObj() {
  const MATH_CONSTANTS = {
    PI: 3.14
  };
  // Only change code below this line

Object.freeze(MATH_CONSTANTS);
  // Only change code above this line
  try {
    MATH_CONSTANTS.PI = 99;
  } catch(ex) {
    console.log(ex);
  }
  return MATH_CONSTANTS.PI;
}
const PI = freezeObj();

//task 4
/*Используйте стрелочные функции для написания кратких анонимных функций
В JavaScript нам часто не нужно называть наши функции, особенно при передаче функции в качестве аргумента 
другой функции. Вместо этого мы создаем встроенные функции. Нам не нужно называть эти функции, потому что мы больше 
нигде их не используем.
Для этого мы часто используем следующий синтаксис:
const myFunc = function() {
  const myVar = "value";
  return myVar;
}
ES6 предоставляет нам синтаксический сахар, позволяющий не писать анонимные функции таким образом.
Вместо этого вы можете использовать синтаксис стрелочной функции :
const myFunc = () => {
  const myVar = "value";
  return myVar;
}
Когда тело функции отсутствует, а есть только возвращаемое значение, синтаксис стрелочной функции позволяет 
опустить ключевое слово, returnа также скобки, окружающие код. Это помогает упростить небольшие функции до однострочных 
инструкций:
const myFunc = () => "value";
Этот код по-прежнему будет возвращать строку valueпо умолчанию.
Перепишите функцию, назначенную переменной magic, которая возвращает a new Date(), чтобы использовать синтаксис 
стрелочной функции. Кроме того, убедитесь, что ничего не определено с использованием ключевого слова var.*/

const magic = () => new Date();

//task 5
/*Напишите стрелочные функции с параметрами
Как и в случае с обычной функцией, вы можете передавать аргументы в функцию со стрелкой.
const doubler = (item) => item * 2;
doubler(4);
doubler(4)вернет значение 8.
Если стрелочная функция имеет один параметр, круглые скобки, заключающие этот параметр, могут быть опущены.
const doubler = item => item * 2;
В стрелочную функцию можно передать более одного аргумента.
const multiplier = (item, multi) => item * multi;
multiplier(4, 2);
multiplier(4, 2)вернет значение 8.
Перепишите myConcatфункцию, которая добавляет содержимое arr2к arr1, чтобы она использовала синтаксис стрелочной функции.*/

const myConcat = (arr1, arr2)=> arr1.concat(arr2);
console.log(myConcat([1, 2], [3, 4, 5]));

//task 6
/*Установите параметры по умолчанию для ваших функций
Чтобы помочь нам создавать более гибкие функции, ES6 вводит параметры по умолчанию для функций.
Проверьте этот код:
const greeting = (name = "Anonymous") => "Hello " + name;
console.log(greeting("John"));
console.log(greeting());
Консоль отобразит строки Hello Johnи Hello Anonymous.
Параметр по умолчанию срабатывает, когда аргумент не указан (он не определен). 
Как вы можете видеть в приведенном выше примере, параметр nameполучит значение по умолчанию, 
Anonymousесли вы не укажете значение для параметра. Вы можете добавить значения по умолчанию для 
любого количества параметров.
Измените функцию increment, добавив параметры по умолчанию, чтобы она добавляла 1, numberесли valueне указано.*/

// Only change code below this line
const increment = (number, value = 1) => number + value;// знвчение по умодчанию (number, value = 1)
// Only change code above this line

//task 7
/*Используйте параметр Rest с параметрами функции
Чтобы помочь нам создавать более гибкие функции, ES6 вводит параметр rest для параметров функции. С помощью 
параметра rest вы можете создавать функции, которые принимают переменное количество аргументов. 
Эти аргументы хранятся в массиве, доступ к которому можно получить позже из функции.

Проверьте этот код:

function howMany(...args) {
  return "You have passed " + args.length + " arguments.";
}
console.log(howMany(0, 1, 2));
console.log(howMany("string", null, [1, 2, 3], { }));
Консоль отобразит строки You have passed 3 arguments.и You have passed 4 arguments..
Параметр rest устраняет необходимость использования argumentsобъекта и позволяет нам использовать 
методы массива для массива параметров, переданных в функцию howMany.
Измените функцию sum, используя оставшийся параметр, таким образом, чтобы функция sumмогла принимать 
любое количество аргументов и возвращать их сумму.*/

function sum(...args) {//решение один, но согласно тестам функцмя будет стрелочной
  let total = 0;
  for (const arg of args) {
    total += arg;
  }
  return total;
}
console.log(sum(0, 1, 2)); 


const sum = (...args) => { // делаем из этого стрелочную функцию
  let total = 0;
  for (const arg of args) {
    total += arg;
  }
  return total;
}

console.log(sum(0, 1, 2)); 
//task 8
/*Алгоритмы JavaScript и структуры данных
ES6
Используйте оператор Spread для оценки массивов на месте
ES6 представляет оператор распространения , который позволяет нам расширять массивы и другие выражения в местах,
где ожидается несколько параметров или элементов.

Код ES5 ниже использует apply()для вычисления максимального значения в массиве:

var arr = [6, 89, 3, 45];
var maximus = Math.max.apply(null, arr);
maximusбудет иметь значение 89.

Мы должны были использовать Math.max.apply(null, arr)потому что Math.max(arr)возвращает NaN. 
Math.max()ожидает аргументы, разделенные запятыми, но не массив. Оператор распространения делает 
этот синтаксис намного более удобным для чтения и обслуживания.

const arr = [6, 89, 3, 45];
const maximus = Math.max(...arr);
maximusбудет иметь значение 89.

...arrвозвращает распакованный массив. Другими словами, он расширяет массив. Однако оператор расширения 
работает только на месте, например, в аргументе функции или в литерале массива. Например:

const spreaded = [...arr];
Однако следующий код не будет работать:

const spreaded = ...arr;
Скопируйте все содержимое arr1в другой массив, arr2используя оператор распространения.*/

const arr1 = ['JAN', 'FEB', 'MAR', 'APR', 'MAY'];
let arr2;
arr2 = [...arr1]  // Change this line
console.log(arr2);

//task 9
/*Используйте присваивание деструктурирования для извлечения значений из объектов
Деструктурирующее присваивание — это специальный синтаксис, введенный в ES6, для аккуратного присваивания значений,
взятых непосредственно из объекта.

Рассмотрим следующий код ES5:

const user = { name: 'John Doe', age: 34 };

const name = user.name;
const age = user.age;
nameбудет иметь значение строки John Doeи ageчисло 34.

Вот эквивалентный оператор присваивания, использующий синтаксис деструктурирования ES6:

const { name, age } = user;
Опять же, nameбудет иметь значение строки John Doeи ageчисло 34.

Здесь будут созданы переменные nameи ageи им будут присвоены значения их 
соответствующих значений из объекта user. Вы можете видеть, насколько это чище.

Вы можете извлечь столько значений из объекта, сколько хотите.


Замените два назначения эквивалентным назначением деструктурирования. Он по-прежнему должен назначать переменные 
todayи tomorrowзначения объекта todayи tomorrowиз HIGH_TEMPERATURESнего.*/

const HIGH_TEMPERATURES = {
  yesterday: 75,
  today: 77,
  tomorrow: 80
};
// Only change code below this line
const { today, tomorrow } = HIGH_TEMPERATURES;
// Only change code above this line

//task 10
/*Используйте назначение деструктурирования для назначения переменных из объектов
Деструктуризация позволяет присваивать новое имя переменной при извлечении значений. Вы можете сделать это,
поместив новое имя после двоеточия при присвоении значения.

Используя тот же объект из последнего примера:

const user = { name: 'John Doe', age: 34 };
Вот как вы можете давать новые имена переменных в присваивании:

const { name: userName, age: userAge } = user;
Вы можете прочитать это как «получить значение user.nameи присвоить его новой переменной с именем userName» и 
так далее. Значением userNameбудет строка John Doe,
а значением userAgeбудет число 34.

Замените два назначения эквивалентным назначением деструктурирования. Он по-прежнему должен назначать 
переменные highTodayи highTomorrowзначения объекта todayи tomorrowиз HIGH_TEMPERATURESнего.*/

const HIGH_TEMPERATURES = {
  yesterday: 75,
  today: 77,
  tomorrow: 80
};

// Only change code below this line
  
const { today: highToday, tomorrow: highTomorrow} = HIGH_TEMPERATURES; 

// Only change code above this line

//task 11
//task 12
//task 13
