//task 1
/*Сравните области действия переменной и пусть ключевые слова
Если вы не знакомы с let, ознакомьтесь с этой задачей о разнице между letиvar .
Когда вы объявляете переменную с varключевым словом, она объявляется глобально или локально, если она объявлена ​​внутри функции.
Ключевое letслово ведет себя аналогично, но с некоторыми дополнительными функциями. Когда вы объявляете переменную с letключевым 
словом внутри блока, оператора или выражения, ее область действия ограничивается этим блоком, оператором или выражением.
Например:
var numArray = [];
for (var i = 0; i < 3; i++) {
  numArray.push(i);
}
console.log(numArray);
console.log(i);
Здесь консоль отобразит значения [0, 1, 2]и 3.
С varключевым словом iобъявляется глобально. Поэтому при i++выполнении он обновляет глобальную переменную. Этот код похож на следующий:
var numArray = [];
var i;
for (i = 0; i < 3; i++) {
  numArray.push(i);
}
console.log(numArray);
console.log(i);
Здесь консоль отобразит значения [0, 1, 2]и 3.
Такое поведение вызовет проблемы, если вы создадите функцию и сохраните ее для последующего использования внутри цикла for,
в котором используется iпеременная. Это связано с тем, что хранимая функция всегда будет ссылаться на значение обновленной глобальной iпеременной.
var printNumTwo;
for (var i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo());
Здесь консоль отобразит значение 3.
Как вы можете видеть, printNumTwo()печатает 3, а не 2. Это связано с тем, что значение, назначенное для, iбыло обновлено, и 
printNumTwo()возвращает глобальное значение i, а не значение, iкоторое было при создании функции в цикле for. Ключевое letслово не следует этому поведению:
let printNumTwo;
for (let i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo());
console.log(i);
Здесь консоль отобразит значение 2и сообщение об ошибке i is not defined.
iне определен, потому что он не был объявлен в глобальной области. Он объявляется только в forоператоре цикла. printNumTwo()вернул 
правильное значение, поскольку три разные iпеременные с уникальными значениями (0, 1 и 2) были созданы ключевым letсловом в операторе цикла.
Исправьте код так, чтобы iобъявленная в ifоператоре переменная была отдельной от iобъявленной в первой строке функции. Убедитесь, что varключевое 
слово нигде в вашем коде не используется.
Это упражнение предназначено для того, чтобы проиллюстрировать разницу между тем, как ключевые слова varи letназначают область действия объявленной переменной. 
При программировании функции, подобной той, что используется в этом упражнении, часто лучше использовать разные имена переменных, чтобы избежать путаницы.
*/
function checkScope() {
let i = 'function scope';
  if (true) {
    let i = 'block scope';
    console.log('Block scope i is: ', i);
  }
  console.log('Function scope i is: ', i);
  return i;
}
checkScope()
//task 2
/*Измените массив, объявленный с помощью const
Если вы не знакомы с const, проверьте этот вызов о constключевом слове .

Объявление constимеет множество вариантов использования в современном JavaScript.

Некоторые разработчики предпочитают присваивать всем своим переменным значение constпо умолчанию, если только они не знают, 
что им потребуется переназначить значение. Только в этом случае они используют let.

Однако важно понимать, что объекты (включая массивы и функции), назначенные переменной с помощью, constпо-прежнему могут
изменяться. Использование constобъявления только предотвращает переназначение идентификатора переменной.

const s = [5, 6, 7];
s = [1, 2, 3];
s[2] = 45;
console.log(s);
s = [1, 2, 3]приведет к ошибке. После комментирования этой строки console.logбудет отображаться значение [5, 6, 45].

Как видите, вы можете изменить [5, 6, 7]сам объект, и переменная sвсе равно будет указывать на измененный массив [5, 6, 45]. 
Как и все массивы, элементы массива sявляются изменяемыми, но поскольку constиспользуется, вы не можете использовать 
идентификатор переменной sдля указания на другой массив с помощью оператора присваивания.

Массив объявляется как const s = [5, 7, 2]. Измените массив на [2, 5, 7]использование различных назначений элементов.*/
const s = [5, 7, 2];
function editInPlace() {
  // Only change code below this line
s[0] = 2;
s[1] = 5;
s[2] = 7;
  // Using s = [2, 5, 7] would be invalid
  // Only change code above this line
}
editInPlace();

//task 3
/*Предотвратить мутацию объекта
Как видно из предыдущей задачи, constобъявление само по себе на самом деле не защищает ваши данные от изменений. Чтобы гарантировать, 
что ваши данные не изменятся, JavaScript предоставляет функцию Object.freezeпредотвращения изменения данных.

Любая попытка изменить объект будет отклонена с выдачей ошибки, если скрипт работает в строгом режиме.

let obj = {
  name:"FreeCodeCamp",
  review:"Awesome"
};
Object.freeze(obj);
obj.review = "bad";
obj.newProp = "Test";
console.log(obj); 
Присваивания obj.reviewи obj.newPropприведут к ошибкам, потому что наш редактор по умолчанию работает в строгом 
режиме, и в консоли будет отображаться значение { name: "FreeCodeCamp", review: "Awesome" }.

В этом задании вы будете использовать Object.freezeдля предотвращения изменения математических констант. 
Вам нужно заморозить MATH_CONSTANTSобъект, чтобы никто не мог изменить значение PI, добавить или удалить свойства.*/

function freezeObj() {
  const MATH_CONSTANTS = {
    PI: 3.14
  };
  // Only change code below this line

Object.freeze(MATH_CONSTANTS);
  // Only change code above this line
  try {
    MATH_CONSTANTS.PI = 99;
  } catch(ex) {
    console.log(ex);
  }
  return MATH_CONSTANTS.PI;
}
const PI = freezeObj();

//task 4
/*Используйте стрелочные функции для написания кратких анонимных функций
В JavaScript нам часто не нужно называть наши функции, особенно при передаче функции в качестве аргумента 
другой функции. Вместо этого мы создаем встроенные функции. Нам не нужно называть эти функции, потому что мы больше нигде их не используем.

Для этого мы часто используем следующий синтаксис:

const myFunc = function() {
  const myVar = "value";
  return myVar;
}
ES6 предоставляет нам синтаксический сахар, позволяющий не писать анонимные функции таким образом.
Вместо этого вы можете использовать синтаксис стрелочной функции :

const myFunc = () => {
  const myVar = "value";
  return myVar;
}
Когда тело функции отсутствует, а есть только возвращаемое значение, синтаксис стрелочной функции позволяет 
опустить ключевое слово, returnа также скобки, окружающие код. Это помогает упростить небольшие функции до однострочных инструкций:

const myFunc = () => "value";
Этот код по-прежнему будет возвращать строку valueпо умолчанию.

Перепишите функцию, назначенную переменной magic, которая возвращает a new Date(), чтобы использовать синтаксис 
стрелочной функции. Кроме того, убедитесь, что ничего не определено с использованием ключевого слова var.*/



//task 5
//task 6
//task 7
//task 8
//task 9
//task 10
